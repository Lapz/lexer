
// This file is automatically generated based on the file `./generated.rs.tera` when `hawthorn::generate` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.
#![allow(bad_style, missing_docs, unreachable_pub)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::traits::{AstNode,self,child_opt,children};
use crate::SyntaxNode;
use SyntaxKind::*;
/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Debug,Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    EOF,
    SEMI, // ;
    COMMA, // ,
    L_PAREN, // (
    R_PAREN, // )
    L_CURLY, // {
    R_CURLY, // }
    L_BRACK, // [
    R_BRACK, // ]
    L_ANGLE, // <
    R_ANGLE, // >
    AMP, // &
    PIPE, // |
    PLUS, // +
    STAR, // *
    SLASH, // /
    CARET, // ^
    PERCENT, // %
    UNDERSCORE, // _
    EXPONENTIAL, // ^
    DOT, // .
    QUESTION, // ?
    MINUS, // -
    FRETURN, // ->
    COLON, // :
    COLON_COLON, // ::
    EQ, // =
    EQEQ, // ==
    FAT_ARROW, // =>
    EXCL, // !
    NEQ, // !=
    LTEQ, // <=
    GTEQ, // >=
    PLUSEQ, // +=
    MINUSEQ, // -=
    STAREQ, // *=
    SLASHEQ, // /=
    AMPAMP, // &&
    PIPEPIPE, // ||
    CLASS_KW, // class
    EXTENDS_KW, // extends
    TYPE_KW, // type
    AS_KW, // as
    MATCH_KW, // match
    ENUM_KW, // enum
    FN_KW, // fn
    LET_KW, // let
    IF_KW, // if
    ELSE_KW, // else
    FOR_KW, // for
    WHILE_KW, // while
    RETURN_KW, // return
    BREAK_KW, // break
    CONTINUE_KW, // continue
    DO_KW, // do
    TRUE_KW, // true
    FALSE_KW, // false
    OR_KW, // or
    AND_KW, // and
    VOID_KW, // void
    EXPORT_KW, // export
    IMPORT_KW, // import
    FROM_KW, // from
    PRINT_KW, // print
    NIL_KW, // nil
    INT_NUMBER,
    FLOAT_NUMBER,
    CHAR,
    STRING,
    ERROR,
    IDENT,
    COMMENT,
    BLOCK,
    SOURCE_FILE,
    CLASS_DEF,
    ENUM_DEF,
    FN_DEF,
    EXTERN_IMPORT_DEF,
    TYPE_ALIAS_DEF,
    BIND_PAT,
    PLACEHOLDER_PAT,
    TUPLE_PAT,
    LITERAL_PAT,
    FN_TYPE,
    PAREN_TYPE,
    ARRAY_TYPE,
    IDENT_TYPE,
    RET_TYPE,
    ARRAY_EXPR,
    CALL_EXPR,
    CAST_EXPR,
    INDEX_EXPR,
    FIELD_EXPR,
    BIN_EXPR,
    PREFIX_EXPR,
    IF_EXPR,
    WHILE_EXPR,
    CONDITION,
    LOOP_EXPR,
    DO_EXPR,
    FOR_EXPR,
    CONTINUE_EXPR,
    BREAK_EXPR,
    BLOCK_EXPR,
    RETURN_EXPR,
    CLOSURE_EXPR,
    PAREN_EXPR,
    MATCH_EXPR,
    MATCH_ARM_LIST,
    MATCH_ARM,
    MATCH_GUARD,
    CLASS_LIT,
    NAMED_FIELD_LIST,
    NAMED_FIELD,
    ENUM_VARIANT,
    NAMED_FIELD_DEF_LIST,
    NAMED_FIELD_DEF,
    POS_FIELD_DEF_LIST,
    POS_FIELD_DEF,
    ENUM_VARIANT_LIST,
    VISIBILITY,
    LITERAL,
    NAME,
    NAME_REF,
    LET_STMT,
    EXPR_STMT,
    TYPE_PARAM_LIST,
    TYPE_PARAM,
    PARAM_LIST,
    PARAM,
    ARG_LIST,
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}


impl From<SyntaxKind> for rowan::cursor::SyntaxKind {
    fn from(kind: SyntaxKind) -> Self {
        Self(kind as u16)
    }
}



// ArgList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARG_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArgList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArgList {
    pub fn args(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// ArrayExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// ArrayType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// BinExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BinExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BinExpr {}

// BindPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BindPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BindPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIND_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BindPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for BindPat {}
impl BindPat {}

// Block
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Block { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Block {
    pub fn statements(&self) -> impl Iterator<Item = Stmt> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// BlockExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BlockExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BlockExpr {
    pub fn block(&self) -> Option<Block> {
        child_opt(self)
    }
}

// BreakExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BreakExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BREAK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BreakExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BreakExpr {}

// CallExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CALL_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CallExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ArgListOwner for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// CastExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CastExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CAST_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CastExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl CastExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// ClassDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClassDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLASS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClassDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for ClassDef {}
impl traits::TypeParamsOwner for ClassDef {}
impl traits::FnDefOwner for ClassDef {}
impl traits::NamedFieldsOwner for ClassDef {}
impl ClassDef {}

// ClassLit
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassLit {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClassLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLASS_LIT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClassLit { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ClassLit {
    pub fn named_field_list(&self) -> Option<NamedFieldList> {
        child_opt(self)
    }
}

// ClosureExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClosureExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLOSURE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClosureExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ClosureExpr {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn body(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// Condition
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Condition {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONDITION => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Condition { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Condition {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ContinueExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ContinueExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONTINUE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ContinueExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ContinueExpr {}

// EnumDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for EnumDef {}
impl EnumDef {
    pub fn variant_list(&self) -> Option<EnumVariantList> {
        child_opt(self)
    }
}

// EnumVariant
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariant { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for EnumVariant {}
impl EnumVariant {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// EnumVariantList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariantList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl EnumVariantList {
    pub fn variants(&self) -> impl Iterator<Item = EnumVariant> {
        children(self)
    }
}

// Expr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | ARRAY_EXPR | PAREN_EXPR | CLOSURE_EXPR | IF_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | CLASS_LIT | CALL_EXPR | INDEX_EXPR | FIELD_EXPR | CAST_EXPR | PREFIX_EXPR | BIN_EXPR | LITERAL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Expr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ExprKind {
    ArrayExpr(ArrayExpr),
    ParenExpr(ParenExpr),
    ClosureExpr(ClosureExpr),
    IfExpr(IfExpr),
    ForExpr(ForExpr),
    WhileExpr(WhileExpr),
    ContinueExpr(ContinueExpr),
    BreakExpr(BreakExpr),
    BlockExpr(BlockExpr),
    ReturnExpr(ReturnExpr),
    MatchExpr(MatchExpr),
    ClassLit(ClassLit),
    CallExpr(CallExpr),
    IndexExpr(IndexExpr),
    FieldExpr(FieldExpr),
    CastExpr(CastExpr),
    PrefixExpr(PrefixExpr),
    BinExpr(BinExpr),
    Literal(Literal),
}
impl From<ArrayExpr> for Expr {
    fn from(n: ArrayExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ParenExpr> for Expr {
    fn from(n: ParenExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ClosureExpr> for Expr {
    fn from(n: ClosureExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<IfExpr> for Expr {
    fn from(n: IfExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ForExpr> for Expr {
    fn from(n: ForExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<WhileExpr> for Expr {
    fn from(n: WhileExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ContinueExpr> for Expr {
    fn from(n: ContinueExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<BreakExpr> for Expr {
    fn from(n: BreakExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<BlockExpr> for Expr {
    fn from(n: BlockExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ReturnExpr> for Expr {
    fn from(n: ReturnExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<MatchExpr> for Expr {
    fn from(n: MatchExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ClassLit> for Expr {
    fn from(n: ClassLit) -> Expr { Expr { syntax: n.syntax } }
}
impl From<CallExpr> for Expr {
    fn from(n: CallExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<IndexExpr> for Expr {
    fn from(n: IndexExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<FieldExpr> for Expr {
    fn from(n: FieldExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<CastExpr> for Expr {
    fn from(n: CastExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<PrefixExpr> for Expr {
    fn from(n: PrefixExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<BinExpr> for Expr {
    fn from(n: BinExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<Literal> for Expr {
    fn from(n: Literal) -> Expr { Expr { syntax: n.syntax } }
}
impl Expr {
    pub fn kind(&self) -> ExprKind {
        match self.syntax.kind() {
            ARRAY_EXPR => ExprKind::ArrayExpr(ArrayExpr::cast(self.syntax.clone()).unwrap()),
            PAREN_EXPR => ExprKind::ParenExpr(ParenExpr::cast(self.syntax.clone()).unwrap()),
            CLOSURE_EXPR => ExprKind::ClosureExpr(ClosureExpr::cast(self.syntax.clone()).unwrap()),
            IF_EXPR => ExprKind::IfExpr(IfExpr::cast(self.syntax.clone()).unwrap()),
            FOR_EXPR => ExprKind::ForExpr(ForExpr::cast(self.syntax.clone()).unwrap()),
            WHILE_EXPR => ExprKind::WhileExpr(WhileExpr::cast(self.syntax.clone()).unwrap()),
            CONTINUE_EXPR => ExprKind::ContinueExpr(ContinueExpr::cast(self.syntax.clone()).unwrap()),
            BREAK_EXPR => ExprKind::BreakExpr(BreakExpr::cast(self.syntax.clone()).unwrap()),
            BLOCK_EXPR => ExprKind::BlockExpr(BlockExpr::cast(self.syntax.clone()).unwrap()),
            RETURN_EXPR => ExprKind::ReturnExpr(ReturnExpr::cast(self.syntax.clone()).unwrap()),
            MATCH_EXPR => ExprKind::MatchExpr(MatchExpr::cast(self.syntax.clone()).unwrap()),
            CLASS_LIT => ExprKind::ClassLit(ClassLit::cast(self.syntax.clone()).unwrap()),
            CALL_EXPR => ExprKind::CallExpr(CallExpr::cast(self.syntax.clone()).unwrap()),
            INDEX_EXPR => ExprKind::IndexExpr(IndexExpr::cast(self.syntax.clone()).unwrap()),
            FIELD_EXPR => ExprKind::FieldExpr(FieldExpr::cast(self.syntax.clone()).unwrap()),
            CAST_EXPR => ExprKind::CastExpr(CastExpr::cast(self.syntax.clone()).unwrap()),
            PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr::cast(self.syntax.clone()).unwrap()),
            BIN_EXPR => ExprKind::BinExpr(BinExpr::cast(self.syntax.clone()).unwrap()),
            LITERAL => ExprKind::Literal(Literal::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Expr {}

// ExprStmt
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXPR_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExprStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ExternImportDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternImportDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExternImportDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXTERN_IMPORT_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExternImportDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExternImportDef {
    pub fn imports(&self) -> Option<Name> {
        child_opt(self)
    }
}

// FieldExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FieldExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FIELD_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FieldExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FieldExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn name_ref(&self) -> Option<NameRef> {
        child_opt(self)
    }
}

// FnDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for FnDef {}
impl traits::TypeParamsOwner for FnDef {}
impl traits::VisibilityOwner for FnDef {}
impl FnDef {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn body(&self) -> Option<Block> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// FnType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FnType {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// ForExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ForExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FOR_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ForExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::LoopBodyOwner for ForExpr {}
impl ForExpr {
    pub fn init(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn cond(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn increment(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// IdentType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IdentType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IDENT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IdentType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IdentType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// IfExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IfExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IF_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IfExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IfExpr {
    pub fn condition(&self) -> Option<Condition> {
        child_opt(self)
    }
}

// IndexExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            INDEX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IndexExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IndexExpr {}

// LetStmt
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LetStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LetStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeAscriptionOwner for LetStmt {}
impl LetStmt {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }

    pub fn initializer(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// Literal
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Literal { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Literal {}

// LiteralPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LiteralPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        child_opt(self)
    }
}

// MatchArm
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArm { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchArm {
    pub fn pats(&self) -> impl Iterator<Item = Pat> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// MatchArmList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArmList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArmList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchArmList {
    pub fn arms(&self) -> impl Iterator<Item = MatchArm> {
        children(self)
    }
}

// MatchExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn match_arm_list(&self) -> Option<MatchArmList> {
        child_opt(self)
    }
}

// Name
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Name { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Name {}

// NameRef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NameRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME_REF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NameRef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NameRef {}

// NamedField
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedField {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedField { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedField {
    pub fn name_ref(&self) -> Option<NameRef> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// NamedFieldDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for NamedFieldDef {}
impl traits::TypeAscriptionOwner for NamedFieldDef {}
impl NamedFieldDef {}

// NamedFieldDefList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDefList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDefList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDefList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = NamedFieldDef> {
        children(self)
    }
}

// NamedFieldList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldList {
    pub fn fields(&self) -> impl Iterator<Item = NamedField> {
        children(self)
    }
}

// Param
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Param { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeAscriptionOwner for Param {}
impl Param {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }
}

// ParamList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParamList {
    pub fn params(&self) -> impl Iterator<Item = Param> {
        children(self)
    }
}

// ParenExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParenExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ParenType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParenType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// Pat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Pat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | BIND_PAT | PLACEHOLDER_PAT | TUPLE_PAT | LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Pat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PatKind {
    BindPat(BindPat),
    PlaceholderPat(PlaceholderPat),
    TuplePat(TuplePat),
    LiteralPat(LiteralPat),
}
impl From<BindPat> for Pat {
    fn from(n: BindPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<PlaceholderPat> for Pat {
    fn from(n: PlaceholderPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<TuplePat> for Pat {
    fn from(n: TuplePat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<LiteralPat> for Pat {
    fn from(n: LiteralPat) -> Pat { Pat { syntax: n.syntax } }
}
impl Pat {
    pub fn kind(&self) -> PatKind {
        match self.syntax.kind() {
            BIND_PAT => PatKind::BindPat(BindPat::cast(self.syntax.clone()).unwrap()),
            PLACEHOLDER_PAT => PatKind::PlaceholderPat(PlaceholderPat::cast(self.syntax.clone()).unwrap()),
            TUPLE_PAT => PatKind::TuplePat(TuplePat::cast(self.syntax.clone()).unwrap()),
            LITERAL_PAT => PatKind::LiteralPat(LiteralPat::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Pat {}

// PlaceholderPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlaceholderPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PlaceholderPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PLACEHOLDER_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PlaceholderPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PlaceholderPat {}

// PrefixExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PREFIX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PrefixExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PrefixExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// RetType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RetType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RET_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RetType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RetType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// ReturnExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ReturnExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RETURN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ReturnExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ReturnExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// SourceFile
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SOURCE_FILE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SourceFile { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ClassDefOwner for SourceFile {}
impl traits::FnDefOwner for SourceFile {}
impl traits::TypeAliasDefOwner for SourceFile {}
impl traits::EnumDefOwner for SourceFile {}
impl traits::ExternImportDefOwner for SourceFile {}
impl SourceFile {}

// Stmt
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Stmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | EXPR_STMT | LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Stmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum StmtKind {
    ExprStmt(ExprStmt),
    LetStmt(LetStmt),
}
impl From<ExprStmt> for Stmt {
    fn from(n: ExprStmt) -> Stmt { Stmt { syntax: n.syntax } }
}
impl From<LetStmt> for Stmt {
    fn from(n: LetStmt) -> Stmt { Stmt { syntax: n.syntax } }
}
impl Stmt {
    pub fn kind(&self) -> StmtKind {
        match self.syntax.kind() {
            EXPR_STMT => StmtKind::ExprStmt(ExprStmt::cast(self.syntax.clone()).unwrap()),
            LET_STMT => StmtKind::LetStmt(LetStmt::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Stmt {}

// TuplePat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TuplePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TuplePat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TuplePat {
    pub fn args(&self) -> impl Iterator<Item = Pat> {
        children(self)
    }
}

// TypeAliasDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAliasDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeAliasDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ALIAS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeAliasDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeAliasDef {}

// TypeParam
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParam { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for TypeParam {}
impl TypeParam {}

// TypeParamList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeParamList {
    pub fn type_params(&self) -> impl Iterator<Item = TypeParam> {
        children(self)
    }
}

// TypeRef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeRef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | PAREN_TYPE | ARRAY_TYPE | FN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeRef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TypeRefKind {
    ParenType(ParenType),
    ArrayType(ArrayType),
    FnType(FnType),
}
impl From<ParenType> for TypeRef {
    fn from(n: ParenType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<ArrayType> for TypeRef {
    fn from(n: ArrayType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<FnType> for TypeRef {
    fn from(n: FnType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl TypeRef {
    pub fn kind(&self) -> TypeRefKind {
        match self.syntax.kind() {
            PAREN_TYPE => TypeRefKind::ParenType(ParenType::cast(self.syntax.clone()).unwrap()),
            ARRAY_TYPE => TypeRefKind::ArrayType(ArrayType::cast(self.syntax.clone()).unwrap()),
            FN_TYPE => TypeRefKind::FnType(FnType::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl TypeRef {}

// Visibility
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Visibility {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            VISIBILITY => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Visibility { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Visibility {}

// WhileExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            WHILE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(WhileExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::LoopBodyOwner for WhileExpr {}
impl WhileExpr {
    pub fn condition(&self) -> Option<Condition> {
        child_opt(self)
    }
}

